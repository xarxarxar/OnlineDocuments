# Unity经验

前言：性能优化需要得知一款游戏更看重性能还是更看重游戏效果，还是兼顾两者，一定要分清主次。

## 1.定制优化指标

比如高中低端级型需要达到什么样的帧数等等，下图为游戏性能优化参考指标(2017年)
![游戏性能优化参考指标](D:\Typora\MyGitDocuments\OnlineDocuments\图片暂存\游戏性能优化参考指标.png)

## 2. 做好效果等级管理

建议将等级管理逻辑抽象成单独的模块，增加QualityManager的角色，负责统筹管理和实现等级相关的逻辑。其它模块要只要调用这模块的接口，可以轻易实现差异化逻辑。此外，QualityManager可以收集游戏关键参数：fps/网络Ping值/流量，对外提供查询接口。

## 3.优化项

### (1)资源优化

#### 1.1 纹理优化：降低纹理大小，提高纹理利用率,使用纹理图集

**降低纹理大小：**压缩贴图适应不同的平台。例如：
Windows可以压缩成DDS，其中DDS细分DX1~DX5共5种格式，每种应用场景略有不同，但它们只能用于DirectX。
Android可以压缩成ETC1（不带Alpha）或ETC2（可带Alpha）。
iOS可以压缩成PVRTC格式。
它们都是GPU直接支持的纹理格式，可以显著减少内存/显存/带宽的占用。
避免使用JPG/高压缩率的PNG/GIF等低质量格式。因为当前主流商业引擎在游戏发布过程中，会自动压缩所有纹理，而保留原画质的纹理可以减少纹理压缩后的画质损失。

**提高纹理利用率：**
a,用九宫格图代替大块背景图。
b,纹理元素通过变换可组合成复合纹理。例下图，上下左右对称的背景图可以用4张相同贴图实例通过旋转/翻转后获得。
![翻转得到更大的纹理](D:\Typora\MyGitDocuments\OnlineDocuments\图片暂存\翻转得到更大的纹理.png)九宫格+UI元素可以组合成很复杂但消耗相对较小的UI界面

**使用纹理图集：**
图集可以降低IO加载次数，也可以减少Draw Calls。
但也有副作用：
1、可能超出设备支持的最大尺寸。
2、可能出现大片空白像素（如下图）。
![纹理出现大片空白](D:\Typora\MyGitDocuments\OnlineDocuments\图片暂存\纹理出现大片空白.png)对于副作用1，可以限制图集的最大尺寸（通常不要超过2048x2048)，分拆成多张图集。对于副作用2，可以针对性地调整纹理元素的布局或尺寸，使得合成的图集尽可能占满有效像素。
适合生成图集的资源有：UI界面，道具图标，角色头像，技能图标，序列帧，特效等等。
如果是Unity引擎，可以用SpritePacker很方便地生成和预览图集。如果是自研引擎，可以用TexturePacker的命令行工具合成。

**UI优化：**使用UI图集，降低UI层次以减少DrawCalls

- 禁用MipMaps。MipMaps的原理是根据绘制对象在绘制空间的大小选取合适的纹理层级，它会增加30%的内存/显存开销。而UI通常都是等长等宽的，跟摄像机距离无关，所以要禁用UI的MipMaps。
- 保持UI纹理的原始尺寸。缩放通常会带来额外的开销，而且会使UI变模糊，降低画质。
- 避免使用大尺寸的背景图。大背景图耗内存，通常还不能共用。可用九宫格+细节图组合而成。

**字体优化：**说字体是性能的杀手毫不为过。游戏使用的字体一般是ttf格式，单个ttf字库少则510M，多则1020M。在文本绘制前，引擎会将字库加载进内存，占用较大的内存空间；在文本绘制时，引擎会在内存中开辟若干张纹理图集缓存字体纹理。

可以通过以下建议优化字体的性能：

- 控制字体文件数量。除了系统默认字体，自定义字体控制在1~2个为宜。
- 少用字体的阴影/描边/发光等效果。
- 剔除字库中无用的字形。可以借助FontSubsetGUI或FontPruner给字库瘦身。

**模型优化：**模型的顶点数据通常包含pos/uv，但color/normal/skin等数据视不同类型的物件区分对待。比如，对于静态物体，可以去除skin；如果无需顶点变色，则可以去除color。
模型内pos.xyz/uv.xy/color.rgba等等数据默认用32位浮点数存储，它们的数据表示范围远远超出大多数游戏的应用场景，可以将它们压缩至16位浮点数。
模型的索引数据存储了三角形引用的顶点序号，默认用32位unsigned int存储，但绝大多数模型不可能超出16位unsigned short的范围，故用16位整型足矣。
Unity引擎在Model的Import面板可设置优化参数（下图）。

![unity模型优化选项](D:\Typora\MyGitDocuments\OnlineDocuments\图片暂存\unity模型优化选项.png)

美术制作出的模型通常是高精度模型，虽然效果好，但往往在中低端机不需要这么高的精度，这时候就要借助一些工具进行优化。下面主要介绍Unity的工具，其它引擎应该有类似的工具。

- MeshBaker：模型合并插件，可以对多个模型合成一个模型，从而减少模型个数，降低Draw Calls。多用于静态物体合并，比如场景和地面静态物体。
- SimpleLOD：模型减面库，可以离线或运行时给模型进行减面优化，也可以方便地做成批处理工具。

一个模型尽量只用一个材质，材质使用的贴图大小要合理，太大浪费内存，太小画质会模糊。建模时，剔除模型内部等不可见的顶点和三角面，合并重叠或相邻的顶点，减少模型的顶点数和面数。为防止美术制作的模型精度过高，有必要对模型的顶点和面数做限制。若模型带骨骼动画，需对骨骼数量做限制，单个模型的骨骼数量最好限定70个以内，否正很多低端设备无法支持GPU蒙皮。对模型进行分类，重要模型骨骼数可以多一些，次重要或不重要的更少骨骼数。游戏Z对各类模型的限制如下表：
![游戏中对各类模型的限制参考](D:\Typora\MyGitDocuments\OnlineDocuments\图片暂存\游戏中对各类模型的限制参考.png)

**场景优化：**

- 地形若是不复杂（比如王者荣耀/LOL的战斗场景），尽量不用Terrain，用简易模型代替，地表细节可用一张纹理表示，地表纹理取合适大小，通常不超过1024x1024。
- 地形网格和地面静态物体去掉阴影，如果某些物件确实需要阴影，可以让美术在制作地表纹理时加上阴影。
- 地形有很多不可见的地方，可以删减那里的模型网格。
- 地面通常有很多装饰物和特效，要关注它们的面数等规格是否超出了限制。
- 一个场景只用一个平行光，实时像素光不要超过一个。用Lighting Map代替实时光，Lighting Map纹理尺寸不宜太大。
- 对场景的面数和物体数量做限制。使用合批工具离线将地表相似的静态物体合并，减少场景复杂度。
- 对场景使用画质分级策略，比如低画质下，用最低模的场景，隐藏场景特效等。
- 地表如有导航网格，导航网格可以采用更精简的模型，复杂的边缘可以简化成简单的几何多边形。

**粒子系统优化：**粒子特效也是性能的一个大杀手，主要体现在：

- 每帧计算量大。涉及发射器/效果器/曲线插值等，耗费CPU性能。

- 频繁操作内存。粒子在生命周期里，实例持续不断地创建/删除，即便有缓存机制下，依然避免不了内存的频繁读取和碎片化。

- 每帧更新数据到GPU。从Lock顶点Buffer到写入数据到GPU，会引发线程等待，也加重CPU到GPU带宽的负担。

- 增加大量Draw Calls。粒子特效通常五花八样，使用很多材质，导致引擎无法合批优化，大量增加绘制次数。

- 导致Overdraw（过绘制）。粒子一般会开启Alpha Blend，在同屏粒子多的情况下，会造成严重的Overdraw。

即然粒子导致性能严重下降，首先得从资源上着手优化和规范。具体方式有：

- 优化粒子属性。关闭阴影，关闭光照；若可以，去掉纹理的Alpha通道，并关闭Alpha Blend和Alpha Test；
- 禁用粒子的高级特效。如模型粒子/模型发射器/粒子碰撞体等。
- 用最少的粒子效果器。关闭不必要的粒子效果器，采用简单的方式代替。
- 控制粒子的材质数量。一个特效通常包含了若干个粒子系统，它们尽量使用内置材质，使用相同的材质实例。
- 控制粒子的尺寸和贴图大小。控制粒子的尺寸，可以减缓过绘制，控制贴图大小，可以减少带宽和提高渲染性能。
- 制定粒子特效美术规范。下面是游戏Z的粒子规范。

> **游戏Z粒子美术规范**
>
> - 单个粒子的发射数量不超过50个。
> - 减少粒子的尺寸，面积越大就会消耗更多的性能。
> - 粒子贴图必须是2的N次方，尽量控制64x64以内，极少量128x128或256x256，最大不超过256x256。
> - 尽可能去掉粒子贴图的Alpha通道。
> - 尽量不用Alpha Test。
> - 尽量使用已有的材质，提高合并渲染的优化概率。
> - 材质优先用Mobile目录下的材质。
> - 尽可能不用模型做粒子，如果使用，要控制模型面数在100以内，最大粒子数在5以内。
> - 单个特效渲染数据限制：
>     - 小型特效（如受击特效、Buff特效）的面数和顶点数在80以内，贴图在64*64以内，材质数2个以内。
>     - 中型特效（如技能特效）的面数和顶点数在150以内，贴图在128*128以内，材质数4个以内。
>     - 大型特效（如全局特效、大火球）的面数和顶点数在300以内，贴图在256*256以内，材质数6个以内。
